--- a/chrome/browser/ui/BUILD.gn
+++ b/chrome/browser/ui/BUILD.gn
@@ -4439,8 +4439,8 @@ static_library("ui") {
       "views/tabs/browser_tab_strip_controller.h",
       "views/tabs/color_picker_view.cc",
       "views/tabs/color_picker_view.h",
-      "views/tabs/compound_tab_container.cc",
-      "views/tabs/compound_tab_container.h",
+      #"views/tabs/compound_tab_container.cc",
+      #"views/tabs/compound_tab_container.h",
       "views/tabs/dragging/drag_session_data.cc",
       "views/tabs/dragging/drag_session_data.h",
       "views/tabs/dragging/dragging_tabs_session.cc",
--- a/chrome/browser/ui/tabs/features.cc
+++ b/chrome/browser/ui/tabs/features.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/ui/tabs/features.h"
 
 #include "base/feature_list.h"
+#include "base/command_line.h"
 #include "chrome/browser/ui/ui_features.h"
 
 namespace tabs {
@@ -75,4 +76,8 @@ bool AreVerticalTabsEnabled() {
   return base::FeatureList::IsEnabled(kVerticalTabs);
 }
 
+bool AreHeliumVerticalTabsEnabled() {
+  return base::CommandLine::ForCurrentProcess()->HasSwitch("helium-vertical-tabs");
+}
+
 }  // namespace tabs
--- a/chrome/browser/ui/tabs/features.h
+++ b/chrome/browser/ui/tabs/features.h
@@ -35,6 +35,7 @@ BASE_DECLARE_FEATURE(kVerticalTabs);
 extern bool CanShowTabSearchPositionSetting();
 extern bool AreTabGroupShortcutsEnabled();
 extern bool AreVerticalTabsEnabled();
+extern bool AreHeliumVerticalTabsEnabled();
 
 }  // namespace tabs
 
--- a/chrome/browser/ui/tabs/tab_style.cc
+++ b/chrome/browser/ui/tabs/tab_style.cc
@@ -169,8 +169,10 @@ SkColor TabStyle::GetTabBackgroundColor(
       return color_provider.GetColor(kSelectedColorIds[hovered][frame_active]);
     }
     case TabStyle::TabSelectionState::kInactive: {
-      constexpr std::array<std::array<ui::ColorId, 2>, 2> kInactiveColorIds = {
+      std::array<std::array<ui::ColorId, 2>, 2> kInactiveColorIds = {
           {{kColorTabBackgroundInactiveFrameInactive,
+            tabs::AreHeliumVerticalTabsEnabled() ?
+            kColorTabBackgroundInactiveFrameInactive :
             kColorTabBackgroundInactiveFrameActive},
            {kColorTabBackgroundInactiveHoverFrameInactive,
             kColorTabBackgroundInactiveHoverFrameActive}}};
--- a/chrome/browser/ui/views/frame/browser_root_view.cc
+++ b/chrome/browser/ui/views/frame/browser_root_view.cc
@@ -343,7 +343,7 @@ bool BrowserRootView::OnMouseWheel(const
   // Scroll-event-changes-tab is incompatible with scrolling tabstrip, so
   // disable it if the latter feature is enabled.
   if (scroll_event_changes_tab_ &&
-      !base::FeatureList::IsEnabled(tabs::kScrollableTabStrip)) {
+      !base::FeatureList::IsEnabled(tabs::kScrollableTabStrip) && !tabs::AreHeliumVerticalTabsEnabled()) {
     // Switch to the left/right tab if the wheel-scroll happens over the
     // tabstrip, or the empty space beside the tabstrip.
     views::View* hit_view = GetEventHandlerForPoint(event.location());
--- a/chrome/browser/ui/views/frame/browser_view.h
+++ b/chrome/browser/ui/views/frame/browser_view.h
@@ -145,7 +145,7 @@ class BrowserView : public BrowserWindow
 
  public:
   // The width of the vertical tab strip.
-  static constexpr int kVerticalTabStripWidth = 240;
+  static constexpr int kVerticalTabStripWidth = 270;
 
   explicit BrowserView(std::unique_ptr<Browser> browser);
   BrowserView(const BrowserView&) = delete;
--- a/chrome/browser/ui/views/frame/browser_view_layout.cc
+++ b/chrome/browser/ui/views/frame/browser_view_layout.cc
@@ -540,10 +540,22 @@ void BrowserViewLayout::LayoutTabStripRe
   if (web_app_frame_toolbar_) {
     tab_strip_region_bounds.Inset(gfx::Insets::TLBR(
         0, 0, 0, web_app_frame_toolbar_->GetPreferredSize().width()));
+  } else if (tabs::AreHeliumVerticalTabsEnabled()) {
+    // if there's anything to the left (e.g. macOS window buttons), offset tab strip.
+    int top_offset = tab_strip_region_bounds.x() != 0 ? tab_strip_region_bounds.height() : 0;
+    tab_strip_region_bounds = gfx::Rect(
+      0, top_offset,
+      BrowserView::kVerticalTabStripWidth, available_bounds.height() - top_offset
+    );
   }
 
   if (tabs::AreVerticalTabsEnabled()) {
     SetViewVisibility(tab_strip_region_view_, false);
+  } else if (tabs::AreHeliumVerticalTabsEnabled()) {
+    SetViewVisibility(tab_strip_region_view_, true);
+    available_bounds.set_x(available_bounds.x() +
+                         BrowserView::kVerticalTabStripWidth);
+    tab_strip_region_view_->SetBoundsRect(tab_strip_region_bounds);
   } else {
     SetViewVisibility(tab_strip_region_view_, true);
     tab_strip_region_view_->SetBoundsRect(tab_strip_region_bounds);
@@ -572,7 +584,7 @@ void BrowserViewLayout::LayoutToolbar(gf
   bool toolbar_visible = delegate_->IsToolbarVisible();
   SetViewVisibility(toolbar_, toolbar_visible);
 
-  if (tabs::AreVerticalTabsEnabled()) {
+  if (tabs::AreVerticalTabsEnabled() || tabs::AreHeliumVerticalTabsEnabled()) {
     // When vertical tabs is enabled, the top element becomes the toolbar.
     // Because of this, it must now be aware of the location of the caption
     // buttons. We can reuse the calculation use by the TabStripRegionView to
@@ -580,6 +592,7 @@ void BrowserViewLayout::LayoutToolbar(gf
     // caption button location directly.
     gfx::Rect toolbar_bounds(
         delegate_->GetBoundsForTabStripRegionInBrowserView());
+
     toolbar_bounds.set_x(available_bounds.x());
     toolbar_bounds.set_width(toolbar_bounds.width() -
                              BrowserView::kVerticalTabStripWidth);
@@ -702,7 +715,7 @@ BrowserViewLayout::CalculateContentsCont
   contents_container_bounds.set_height(available_bounds.height() -
                                        available_bounds.y());
   int vertical_tab_offset = 0;
-  if (tabs::AreVerticalTabsEnabled()) {
+  if (tabs::AreVerticalTabsEnabled() || tabs::AreHeliumVerticalTabsEnabled()) {
     vertical_tab_offset = BrowserView::kVerticalTabStripWidth;
     contents_container_bounds.set_width(available_bounds.width() -
                                         vertical_tab_offset);
--- a/chrome/browser/ui/views/frame/tab_strip_region_view.cc
+++ b/chrome/browser/ui/views/frame/tab_strip_region_view.cc
@@ -18,6 +18,7 @@
 #include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/tabs/tab_strip_prefs.h"
 #include "chrome/browser/ui/ui_features.h"
+#include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/ui/views/chrome_layout_provider.h"
 #include "chrome/browser/ui/views/commerce/product_specifications_button.h"
 #include "chrome/browser/ui/views/tab_search_bubble_host.h"
@@ -114,6 +115,10 @@ TabStripRegionView::TabStripRegionView(s
       this, views::kCascadingBackgroundColor,
       kColorTabBackgroundInactiveFrameInactive);
 
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    SetBackground(views::CreateSolidBackground(kColorTabBackgroundInactiveFrameInactive));
+  }
+
   SetLayoutManager(std::make_unique<views::FlexLayout>())
       ->SetOrientation(views::LayoutOrientation::kHorizontal);
 
@@ -129,6 +134,7 @@ TabStripRegionView::TabStripRegionView(s
   std::unique_ptr<TabStripActionContainer> tab_strip_action_container;
   std::unique_ptr<ProductSpecificationsButton> product_specifications_button;
   if (browser &&
+      !tabs::AreHeliumVerticalTabsEnabled() &&
       !base::CommandLine::ForCurrentProcess()->HasSwitch("remove-tabsearch-button") &&
       (browser->GetType() == BrowserWindowInterface::Type::TYPE_NORMAL)) {
     if (features::HasTabSearchToolbarButton()) {
@@ -181,7 +187,7 @@ TabStripRegionView::TabStripRegionView(s
     }
   }
 
-  if (base::FeatureList::IsEnabled(tabs::kScrollableTabStrip)) {
+  if (base::FeatureList::IsEnabled(tabs::kScrollableTabStrip) || tabs::AreHeliumVerticalTabsEnabled()) {
     std::unique_ptr<TabStripScrollContainer> scroll_container =
         std::make_unique<TabStripScrollContainer>(std::move(tab_strip));
     tab_strip_scroll_container_ = scroll_container.get();
@@ -189,7 +195,9 @@ TabStripRegionView::TabStripRegionView(s
     // Allow the |tab_strip_container_| to grow into the free space available in
     // the TabStripRegionView.
     const views::FlexSpecification tab_strip_container_flex_spec =
-        views::FlexSpecification(views::LayoutOrientation::kHorizontal,
+        views::FlexSpecification(tabs::AreHeliumVerticalTabsEnabled() ?
+                                 views::LayoutOrientation::kVertical :
+                                 views::LayoutOrientation::kHorizontal,
                                  views::MinimumFlexSizeRule::kScaleToMinimum,
                                  views::MaximumFlexSizeRule::kPreferred);
     tab_strip_container_->SetProperty(views::kFlexBehaviorKey,
@@ -208,7 +216,7 @@ TabStripRegionView::TabStripRegionView(s
                                       tab_strip_container_flex_spec);
   }
 
-  if (ShouldShowNewTabButton(browser)) {
+  if (ShouldShowNewTabButton(browser) && !tabs::AreHeliumVerticalTabsEnabled()) {
     std::unique_ptr<TabStripControlButton> tab_strip_control_button =
         std::make_unique<TabStripControlButton>(
             tab_strip_->controller(),
@@ -231,17 +239,20 @@ TabStripRegionView::TabStripRegionView(s
           ui::EF_MIDDLE_MOUSE_BUTTON);
   }
 
-  reserved_grab_handle_space_ =
-      AddChildView(std::make_unique<FrameGrabHandle>());
-  reserved_grab_handle_space_->SetProperty(
-      views::kFlexBehaviorKey,
-      views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,
-                               views::MaximumFlexSizeRule::kUnbounded)
-          .WithOrder(3));
+  if (!tabs::AreHeliumVerticalTabsEnabled()) {
+    reserved_grab_handle_space_ =
+        AddChildView(std::make_unique<FrameGrabHandle>());
+    reserved_grab_handle_space_->SetProperty(
+        views::kFlexBehaviorKey,
+        views::FlexSpecification(views::MinimumFlexSizeRule::kPreferred,
+                                 views::MaximumFlexSizeRule::kUnbounded)
+            .WithOrder(3));
+  }
 
   SetProperty(views::kElementIdentifierKey, kTabStripRegionElementId);
 
-  if (browser && tab_search_container && !render_tab_search_before_tab_strip_) {
+  if (browser && tab_search_container && !render_tab_search_before_tab_strip_
+      && !tabs::AreHeliumVerticalTabsEnabled()) {
     if (product_specifications_button) {
       product_specifications_button_ =
           AddChildView(std::move(product_specifications_button));
@@ -255,6 +266,7 @@ TabStripRegionView::TabStripRegionView(s
     tab_strip_action_container_ =
         AddChildView(std::move(tab_strip_action_container));
   }
+
   UpdateTabStripMargin();
 }
 
@@ -315,7 +327,7 @@ bool TabStripRegionView::IsRectInWindowC
   // true.
   if (tab_strip_container_->HitTestRect(
           get_target_rect(tab_strip_container_))) {
-    if (base::FeatureList::IsEnabled(tabs::kScrollableTabStrip)) {
+    if (base::FeatureList::IsEnabled(tabs::kScrollableTabStrip) || tabs::AreHeliumVerticalTabsEnabled()) {
       TabStripScrollContainer* scroll_container =
           views::AsViewClass<TabStripScrollContainer>(tab_strip_container_);
 
@@ -412,7 +424,7 @@ views::View::Views TabStripRegionView::G
 // manually calculated.
 void TabStripRegionView::Layout(PassKey) {
   const bool tab_search_container_before_tab_strip =
-      tab_search_container_ && render_tab_search_before_tab_strip_;
+      tab_search_container_ && render_tab_search_before_tab_strip_ && !tabs::AreHeliumVerticalTabsEnabled();
   if (tab_search_container_before_tab_strip) {
     UpdateTabStripMargin();
   }
@@ -559,6 +571,11 @@ void TabStripRegionView::UpdateButtonBor
 }
 
 void TabStripRegionView::UpdateTabStripMargin() {
+  // Vertical tab strip has constant size defined by BrowserViewLayout.
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    return;
+  }
+
   // The new tab button overlaps the tabstrip. Render it to a layer and adjust
   // the tabstrip right margin to reserve space for it.
   std::optional<int> tab_strip_right_margin;
--- a/chrome/browser/ui/views/tabs/tab_container.h
+++ b/chrome/browser/ui/views/tabs/tab_container.h
@@ -54,6 +54,8 @@ class TabContainer : public views::View,
   // the width of the tabstrip.
   virtual void SetAvailableWidthCallback(
       base::RepeatingCallback<int()> available_width_callback) = 0;
+  virtual void SetAvailableHeightCallback(
+      base::RepeatingCallback<int()> available_height_callback) = 0;
 
   // Handle model changes.
   virtual std::vector<Tab*> AddTabs(
@@ -163,6 +165,7 @@ class TabContainer : public views::View,
 
   // Returns the total width available for the TabContainer's use.
   virtual int GetAvailableWidthForTabContainer() const = 0;
+  virtual int GetAvailableHeightForTabContainer() const = 0;
 
   // See `in_tab_close_` for details on tab closing mode. `source` is the input
   // method used to enter tab closing mode, which determines how it is exited
--- a/chrome/browser/ui/views/tabs/tab_container_impl.cc
+++ b/chrome/browser/ui/views/tabs/tab_container_impl.cc
@@ -140,6 +140,10 @@ void TabContainerImpl::SetAvailableWidth
     base::RepeatingCallback<int()> available_width_callback) {
   available_width_callback_ = available_width_callback;
 }
+void TabContainerImpl::SetAvailableHeightCallback(
+    base::RepeatingCallback<int()> available_height_callback) {
+  available_height_callback_ = available_height_callback;
+}
 
 std::vector<Tab*> TabContainerImpl::AddTabs(
     std::vector<TabInsertionParams> tabs_params) {
@@ -256,7 +260,7 @@ void TabContainerImpl::SetActiveTab(std:
     CompleteAnimationAndLayout();
   }
 
-  if (base::FeatureList::IsEnabled(tabs::kScrollableTabStrip) &&
+  if ((base::FeatureList::IsEnabled(tabs::kScrollableTabStrip) || tabs::AreHeliumVerticalTabsEnabled()) &&
       new_active_index.has_value()) {
     ScrollTabToVisible(new_active_index.value());
   }
@@ -327,14 +331,33 @@ void TabContainerImpl::ScrollTabToVisibl
 
   // If the tab strip won't be scrollable after the current tabstrip animations
   // complete, scroll animation wouldn't be meaningful.
-  if (tabs_view_model_.ideal_bounds(GetTabCount() - 1).right() <=
-      GetAvailableWidthForTabContainer()) {
-    return;
+  if (!tabs::AreHeliumVerticalTabsEnabled()) {
+    if (tabs_view_model_.ideal_bounds(GetTabCount() - 1).right() <=
+        GetAvailableWidthForTabContainer()) {
+      return;
+    }
   }
 
   gfx::Rect active_tab_ideal_bounds =
       tabs_view_model_.ideal_bounds(model_index);
 
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    bool scroll_to_bottom = active_tab_ideal_bounds.y() < visible_content_rect->y();
+
+    if (scroll_to_bottom) {
+      int start_left_edge(visible_content_rect->y());
+      int target_left_edge(active_tab_ideal_bounds.y());
+
+      AnimateScrollToShowYCoordinate(start_left_edge, target_left_edge);
+    } else {
+      int start_right_edge(visible_content_rect->bottom());
+      int target_right_edge(active_tab_ideal_bounds.bottom());
+      AnimateScrollToShowYCoordinate(start_right_edge, target_right_edge);
+    }
+
+    return;
+  }
+
   if ((active_tab_ideal_bounds.x() >= visible_content_rect->x()) &&
       (active_tab_ideal_bounds.right() <= visible_content_rect->right())) {
     return;
@@ -365,6 +388,15 @@ void TabContainerImpl::ScrollTabContaine
     return;
   }
 
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    int start_edge =
+      (offset > 0) ? visible_content_rect->bottom() : visible_content_rect->y();
+
+    AnimateScrollToShowYCoordinate(start_edge, start_edge + offset);
+
+    return;
+  }
+
   // If tabcontainer is scrolled towards trailing tab, the start edge should
   // have the x coordinate of the right bound. If it is scrolled towards the
   // leading tab it should have the x coordinate of the left bound.
@@ -452,6 +484,11 @@ void TabContainerImpl::ToggleTabGroup(
             ? CloseTabSource::kFromMouse
             : CloseTabSource::kFromTouch;
 
+    if (tabs::AreHeliumVerticalTabsEnabled()) {
+      EnterTabClosingMode(std::nullopt, source);
+      return;
+    }
+
     EnterTabClosingMode(
         tabs_view_model_.ideal_bounds(GetTabCount() - 1).right() -
             current_group_width + collapsed_group_width,
@@ -721,6 +758,12 @@ int TabContainerImpl::GetAvailableWidthF
              : parent()->GetAvailableSize(this).width().value();
 }
 
+int TabContainerImpl::GetAvailableHeightForTabContainer() const {
+  return available_height_callback_
+             ? available_height_callback_.Run()
+             : parent()->GetAvailableSize(this).height().value();
+}
+
 void TabContainerImpl::EnterTabClosingMode(std::optional<int> override_width,
                                            CloseTabSource source) {
   // Tab closing mode only makes sense if the tab was closed as a direct result
@@ -792,7 +835,7 @@ void TabContainerImpl::SetTabSlotVisibil
     const bool is_collapsed =
         (current_group.has_value() &&
          controller_->IsGroupCollapsed(current_group.value()) &&
-         tab->bounds().width() <= tab->tab_style()->GetTabOverlap());
+         (tabs::AreHeliumVerticalTabsEnabled() ? true : tab->bounds().width() <= tab->tab_style()->GetTabOverlap()));
     const bool should_be_visible = is_collapsed ? false : last_tab_visible;
 
     // If we change the visibility of a tab in a group, we must recalculate that
@@ -883,6 +926,10 @@ void TabContainerImpl::PaintChildren(con
 }
 
 gfx::Size TabContainerImpl::GetMinimumSize() const {
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    return gfx::Size(BrowserView::kVerticalTabStripWidth, GetLayoutConstant(TAB_STRIP_HEIGHT));
+  }
+
   // During animations, our minimum width tightly hugs the current bounds of our
   // children.
   std::optional<int> minimum_width = GetMidAnimationTrailingX();
@@ -900,6 +947,25 @@ gfx::Size TabContainerImpl::GetMinimumSi
 
 gfx::Size TabContainerImpl::CalculatePreferredSize(
     const views::SizeBounds& available_size) const {
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    int max_y = 0;
+    int tabs_height = 0;
+
+    // The visual order of the tabs can be out of sync with the logical order,
+    // so we have to check all of them to find the visually trailing-most one.
+    for (views::View* child : children()) {
+      max_y = std::max(max_y, child->bounds().bottom());
+      tabs_height += child->height();
+    }
+
+    /*if (tabs_height < GetAvailableHeightForTabContainer()) {
+      max_y = GetAvailableHeightForTabContainer();
+    }*/
+
+    return gfx::Size(available_size.width().value_or(BrowserView::kVerticalTabStripWidth),
+                     max_y);
+  }
+
   // During animations, our preferred width tightly hugs the current bounds of
   // our children.
   std::optional<int> preferred_width = GetMidAnimationTrailingX();
@@ -1214,6 +1280,22 @@ void TabContainerImpl::AnimateScrollToSh
   tab_scrolling_animation_->Start();
 }
 
+void TabContainerImpl::AnimateScrollToShowYCoordinate(const int start_edge,
+                                                      const int target_edge) {
+  if (tab_scrolling_animation_) {
+    tab_scrolling_animation_->Stop();
+  }
+
+
+  gfx::Rect start_rect(0, start_edge, 0, 0);
+  gfx::Rect target_rect(0, target_edge, 0, 0);
+
+  tab_scrolling_animation_ = std::make_unique<TabScrollingAnimation>(
+      scroll_contents_view_, bounds_animator_.container(), start_rect,
+      target_rect);
+  tab_scrolling_animation_->Start();
+}
+
 void TabContainerImpl::AnimateTabSlotViewTo(TabSlotView* tab_slot_view,
                                             const gfx::Rect& target_bounds) {
   // If we don't own the tab, let our controller handle it.
@@ -1286,14 +1368,22 @@ void TabContainerImpl::StartInsertTabAni
   // Adjust the starting bounds of the new tab.
   const int tab_overlap = TabStyle::Get()->GetTabOverlap();
   if (model_index > 0) {
-    // If we have a tab to our left, start at its right edge.
-    bounds.set_x(GetTabAtModelIndex(model_index - 1)->bounds().right() -
-                 tab_overlap);
+    if (tabs::AreHeliumVerticalTabsEnabled()) {
+      bounds.set_y(GetTabAtModelIndex(model_index - 1)->bounds().y() + TabStyle::Get()->GetStandardHeight());
+    } else {
+      // If we have a tab to our left, start at its right edge.
+      bounds.set_x(GetTabAtModelIndex(model_index - 1)->bounds().right() -
+                   tab_overlap);
+    }
   } else {
     CHECK_LT(model_index + 1, GetTabCount())
         << "First tab inserted into the tabstrip should not animate.";
-    // Otherwise, if we have a tab to our right, start at its left edge.
-    bounds.set_x(GetTabAtModelIndex(model_index + 1)->bounds().x());
+    if (tabs::AreHeliumVerticalTabsEnabled()) {
+      bounds.set_y(GetTabAtModelIndex(model_index + 1)->bounds().bottom() + TabStyle::Get()->GetStandardHeight());
+    } else {
+      // Otherwise, if we have a tab to our right, start at its left edge.
+      bounds.set_x(GetTabAtModelIndex(model_index + 1)->bounds().x());
+    }
   }
 
   // Start at the width of the overlap in order to animate at the same speed
@@ -1313,7 +1403,8 @@ void TabContainerImpl::StartRemoveTabAni
   UpdateIdealBounds();
   if (in_tab_close_ && GetTabCount() > 0 &&
       override_available_width_for_tabs_ >
-          tabs_view_model_.ideal_bounds(GetTabCount() - 1).right()) {
+      (tabs::AreHeliumVerticalTabsEnabled() ? true : override_available_width_for_tabs_ >
+          tabs_view_model_.ideal_bounds(GetTabCount() - 1).right())) {
     // Tab closing mode is no longer constraining tab widths - they're at full
     // size. Exit tab closing mode so that it doesn't artificially inflate our
     // bounds.
@@ -1364,11 +1455,15 @@ gfx::Rect TabContainerImpl::GetTargetBou
   // Compute the target bounds for animating this tab closed.  The tab's left
   // edge should stay joined to the right edge of the previous tab, if any.
   gfx::Rect target_bounds = tab->bounds();
-  target_bounds.set_x(
-      (former_model_index > 0)
-          ? (tabs_view_model_.ideal_bounds(former_model_index - 1).right() -
-             tab_overlap)
-          : 0);
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    target_bounds.set_x(0);
+  } else {
+    target_bounds.set_x(
+       (former_model_index > 0)
+           ? (tabs_view_model_.ideal_bounds(former_model_index - 1).right() -
+              tab_overlap)
+           : 0);
+  }
 
   // The tab should animate to the width of the overlap in order to close at the
   // same speed the surrounding tabs are moving, since at this width the
@@ -1648,7 +1743,7 @@ bool TabContainerImpl::ShouldTabBeVisibl
   // N.B. This is separate from the tab being potentially scrolled offscreen -
   // this solely determines whether the tab should be clipped for the
   // pre-scrolling overflow behavior.
-  if (base::FeatureList::IsEnabled(tabs::kScrollableTabStrip)) {
+  if (base::FeatureList::IsEnabled(tabs::kScrollableTabStrip) || tabs::AreHeliumVerticalTabsEnabled()) {
     return true;
   }
 
@@ -1817,4 +1912,5 @@ bool TabContainerImpl::IsValidModelIndex
 
 BEGIN_METADATA(TabContainerImpl)
 ADD_READONLY_PROPERTY_METADATA(int, AvailableWidthForTabContainer)
+ADD_READONLY_PROPERTY_METADATA(int, AvailableHeightForTabContainer)
 END_METADATA
--- a/chrome/browser/ui/views/tabs/tab_container_impl.h
+++ b/chrome/browser/ui/views/tabs/tab_container_impl.h
@@ -51,6 +51,8 @@ class TabContainerImpl : public TabConta
   // TabContainer:
   void SetAvailableWidthCallback(
       base::RepeatingCallback<int()> available_width_callback) override;
+  void SetAvailableHeightCallback(
+      base::RepeatingCallback<int()> available_height_callback) override;
 
   std::vector<Tab*> AddTabs(
       std::vector<TabInsertionParams> tabs_params) override;
@@ -117,6 +119,7 @@ class TabContainerImpl : public TabConta
   void CompleteAnimationAndLayout() override;
 
   int GetAvailableWidthForTabContainer() const override;
+  int GetAvailableHeightForTabContainer() const override;
 
   void EnterTabClosingMode(std::optional<int> override_width,
                            CloseTabSource source) override;
@@ -224,6 +227,8 @@ class TabContainerImpl : public TabConta
   // bounds of the tabstrip.
   void AnimateScrollToShowXCoordinate(const int start_edge,
                                       const int target_edge);
+  void AnimateScrollToShowYCoordinate(const int start_edge,
+                                      const int target_edge);
   // Animates `tab_slot_view` to `target_bounds`
   void AnimateTabSlotViewTo(TabSlotView* tab_slot_view,
                             const gfx::Rect& target_bounds);
@@ -395,6 +400,7 @@ class TabContainerImpl : public TabConta
   bool in_tab_close_ = false;
 
   base::RepeatingCallback<int()> available_width_callback_;
+  base::RepeatingCallback<int()> available_height_callback_;
 };
 
 #endif  // CHROME_BROWSER_UI_VIEWS_TABS_TAB_CONTAINER_IMPL_H_
--- a/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.cc
+++ b/chrome/browser/ui/views/tabs/tab_hover_card_bubble_view.cc
@@ -24,6 +24,7 @@
 #include "chrome/browser/ui/tabs/saved_tab_groups/collaboration_messaging_tab_data.h"
 #include "chrome/browser/ui/tabs/tab_renderer_data.h"
 #include "chrome/browser/ui/tabs/tab_style.h"
+#include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/thumbnails/thumbnail_image.h"
 #include "chrome/browser/ui/ui_features.h"
 #include "chrome/browser/ui/views/chrome_typography.h"
@@ -362,6 +363,8 @@ DEFINE_CLASS_ELEMENT_IDENTIFIER_VALUE(Ta
 TabHoverCardBubbleView::TabHoverCardBubbleView(Tab* tab,
                                                const InitParams& params)
     : BubbleDialogDelegateView(tab,
+                               tabs::AreHeliumVerticalTabsEnabled() ?
+                               views::BubbleBorder::LEFT_TOP :
                                views::BubbleBorder::TOP_LEFT,
                                views::BubbleBorder::STANDARD_SHADOW),
       tab_style_(TabStyle::Get()),
--- a/chrome/browser/ui/views/tabs/tab_strip.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip.cc
@@ -59,7 +59,7 @@
 #include "chrome/browser/ui/view_ids.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
 #include "chrome/browser/ui/views/tabs/browser_tab_strip_controller.h"
-#include "chrome/browser/ui/views/tabs/compound_tab_container.h"
+//#include "chrome/browser/ui/views/tabs/compound_tab_container.h"
 #include "chrome/browser/ui/views/tabs/dragging/tab_drag_controller.h"
 #include "chrome/browser/ui/views/tabs/tab.h"
 #include "chrome/browser/ui/views/tabs/tab_container_impl.h"
@@ -136,10 +136,13 @@ std::unique_ptr<TabContainer> MakeTabCon
     TabStrip* tab_strip,
     TabHoverCardController* hover_card_controller,
     TabDragContext* drag_context) {
+  /*
   if (base::FeatureList::IsEnabled(tabs::kSplitTabStrip)) {
+
     return std::make_unique<CompoundTabContainer>(
         *tab_strip, hover_card_controller, drag_context, *tab_strip, tab_strip);
   }
+  */
   return std::make_unique<TabContainerImpl>(
       *tab_strip, hover_card_controller, drag_context, *tab_strip, tab_strip);
 }
@@ -177,6 +180,15 @@ class TabStrip::TabDragContextImpl : pub
 
   gfx::Size CalculatePreferredSize(
       const views::SizeBounds& available_size) const override {
+
+    int max_child_y = 0;
+    for (views::View* child : children()) {
+      if (!views::IsViewClass<TabSlotView>(child)) {
+        continue;
+      }
+      max_child_y = std::max(max_child_y, child->bounds().bottom());
+    }
+
     int max_child_x = 0;
     for (views::View* child : children()) {
       if (!views::IsViewClass<TabSlotView>(child)) {
@@ -185,7 +197,7 @@ class TabStrip::TabDragContextImpl : pub
       max_child_x = std::max(max_child_x, child->bounds().right());
     }
 
-    return gfx::Size(max_child_x, GetLayoutConstant(TAB_HEIGHT));
+    return gfx::Size(max_child_x, max_child_y);
   }
 
   bool OnMouseDragged(const ui::MouseEvent& event) override {
@@ -1111,6 +1123,11 @@ void TabStrip::SetAvailableWidthCallback
   tab_container_->SetAvailableWidthCallback(available_width_callback);
 }
 
+void TabStrip::SetAvailableHeightCallback(
+    base::RepeatingCallback<int()> available_height_callback) {
+  tab_container_->SetAvailableHeightCallback(available_height_callback);
+}
+
 // static
 int TabStrip::GetSizeNeededForViews(const std::vector<TabSlotView*>& views) {
   int width = 0;
@@ -2168,6 +2185,13 @@ gfx::Size TabStrip::CalculatePreferredSi
 }
 
 void TabStrip::Layout(PassKey) {
+  if(tabs::AreHeliumVerticalTabsEnabled()) {
+    const int required_height = GetPreferredSize().height();
+    const int available_height =
+        tab_container_->GetAvailableHeightForTabContainer();
+
+    SetBounds(0, 0, GetPreferredSize().width(), std::max(available_height, required_height));
+  } else
   if (base::FeatureList::IsEnabled(tabs::kScrollableTabStrip)) {
     // With tab scrolling, the TabStrip is the contents view of a ScrollView and
     // as such is expected to set its own bounds during layout.
--- a/chrome/browser/ui/views/tabs/tab_strip.h
+++ b/chrome/browser/ui/views/tabs/tab_strip.h
@@ -86,6 +86,8 @@ class TabStrip : public views::View,
 
   void SetAvailableWidthCallback(
       base::RepeatingCallback<int()> available_width_callback);
+  void SetAvailableHeightCallback(
+      base::RepeatingCallback<int()> available_height_callback);
 
   void NewTabButtonPressed(const ui::Event& event);
 
--- a/chrome/browser/ui/views/tabs/tab_strip_layout.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip_layout.cc
@@ -10,6 +10,9 @@
 #include <optional>
 #include <set>
 
+#include "chrome/browser/ui/tabs/features.h"
+#include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/browser/ui/views/tabs/tab_group_underline.h" // for kStrokeThickness
 #include "chrome/browser/ui/tabs/tab_style.h"
 #include "chrome/browser/ui/views/tabs/tab_strip_layout_types.h"
 #include "components/tabs/public/split_tab_id.h"
@@ -146,6 +149,24 @@ std::pair<std::vector<gfx::Rect>, Layout
             LayoutDomain::kInactiveWidthEqualsActiveWidth};
   }
 
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    int next_y = 0;
+    std::vector<gfx::Rect> bounds;
+
+    for (const TabWidthConstraints& tab : tabs) {
+      if (tab.get_state().IsClosed()) {
+        bounds.emplace_back(0, next_y, BrowserView::kVerticalTabStripWidth, 0);
+      } else {
+        int left_padding = tab.IsPartOfGroup() ? TabGroupUnderline::kStrokeThickness * 5 : 0;
+        bounds.emplace_back(left_padding, next_y, BrowserView::kVerticalTabStripWidth - left_padding,
+                            TabStyle::Get()->GetStandardHeight());
+        next_y += TabStyle::Get()->GetStandardHeight();
+      }
+    }
+
+    return {bounds, LayoutDomain::kInactiveWidthEqualsActiveWidth};
+  }
+
   TabSizer tab_sizer = CalculateSpaceFractionAvailable(tabs, width);
 
   int next_x = 0;
--- a/chrome/browser/ui/views/tabs/tab_strip_layout_helper.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip_layout_helper.cc
@@ -278,7 +278,14 @@ TabStripLayoutHelper::CalculateIdealBoun
         TabLayoutState(open, pinned, active, slots_[i].view->split());
     TabSizeInfo size_info = slots_[i].view->GetTabSizeInfo();
 
-    tab_widths.emplace_back(state, size_info);
+    bool is_part_of_group = false;
+
+    if (slots_[i].type == TabSlotView::ViewType::kTab) {
+      Tab* tab = static_cast<Tab*>(slots_[i].view);
+      is_part_of_group = tab->GetGroupColor().has_value();
+    }
+
+    tab_widths.emplace_back(state, size_info, is_part_of_group);
   }
 
   return CalculateTabBounds(tab_widths, available_width);
--- a/chrome/browser/ui/views/tabs/tab_strip_scroll_container.cc
+++ b/chrome/browser/ui/views/tabs/tab_strip_scroll_container.cc
@@ -12,6 +12,7 @@
 #include "chrome/app/vector_icons/vector_icons.h"
 #include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/ui/ui_features.h"
+#include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/views/tabs/tab_strip.h"
 #include "chrome/browser/ui/views/tabs/tab_strip_controller.h"
 #include "chrome/browser/ui/views/tabs/tab_strip_scrolling_overflow_indicator_strategy.h"
@@ -104,15 +105,25 @@ TabStripScrollContainer::TabStripScrollC
   tab_strip->SetAvailableWidthCallback(
       base::BindRepeating(&TabStripScrollContainer::GetTabStripAvailableWidth,
                           base::Unretained(this)));
+  tab_strip->SetAvailableHeightCallback(
+      base::BindRepeating(&TabStripScrollContainer::GetTabStripAvailableHeight,
+                          base::Unretained(this)));
 
   std::unique_ptr<views::ScrollView> scroll_view =
       std::make_unique<views::ScrollView>(
           views::ScrollView::ScrollWithLayers::kEnabled);
   scroll_view_ = scroll_view.get();
   scroll_view->SetBackgroundColor(std::nullopt);
-  scroll_view->SetHorizontalScrollBarMode(
-      views::ScrollView::ScrollBarMode::kHiddenButEnabled);
-  scroll_view->SetTreatAllScrollEventsAsHorizontal(true);
+
+  if (tabs::AreHeliumVerticalTabsEnabled()) {
+    scroll_view->SetVerticalScrollBarMode(
+      views::ScrollView::ScrollBarMode::kEnabled);
+  } else {
+    scroll_view->SetHorizontalScrollBarMode(
+        views::ScrollView::ScrollBarMode::kHiddenButEnabled);
+    scroll_view->SetTreatAllScrollEventsAsHorizontal(true);
+  }
+
   scroll_view->SetContents(std::move(tab_strip));
 
   overflow_indicator_strategy_ =
@@ -133,7 +144,7 @@ TabStripScrollContainer::TabStripScrollC
       base::BindRepeating(&TabStripScrollContainer::OnContentsScrolledCallback,
                           base::Unretained(this)));
 
-  if (!base::FeatureList::IsEnabled(features::kTabScrollingButtonPosition)) {
+  if (!base::FeatureList::IsEnabled(features::kTabScrollingButtonPosition) || tabs::AreHeliumVerticalTabsEnabled()) {
     leading_scroll_button_ = nullptr;
     trailing_scroll_button_ = nullptr;
     overflow_view_ = AddChildView(
@@ -234,6 +245,10 @@ int TabStripScrollContainer::GetTabStrip
   return overflow_view_->GetAvailableSize(scroll_view_).width().value();
 }
 
+int TabStripScrollContainer::GetTabStripAvailableHeight() const {
+  return overflow_view_->GetAvailableSize(scroll_view_).height().value();
+}
+
 void TabStripScrollContainer::ScrollTowardsLeadingTab() {
   gfx::Rect visible_content = scroll_view_->GetVisibleRect();
   tab_strip()->ScrollTowardsLeadingTabs(visible_content.width());
--- a/chrome/browser/ui/views/tabs/tab_strip_scroll_container.h
+++ b/chrome/browser/ui/views/tabs/tab_strip_scroll_container.h
@@ -53,6 +53,7 @@ class TabStripScrollContainer : public v
 
  private:
   int GetTabStripAvailableWidth() const;
+  int GetTabStripAvailableHeight() const;
 
   // Scrolls the tabstrip towards the first tab in the tabstrip.
   void ScrollTowardsLeadingTab();
--- a/chrome/browser/ui/views/tabs/tab_style_views.cc
+++ b/chrome/browser/ui/views/tabs/tab_style_views.cc
@@ -21,6 +21,7 @@
 #include "chrome/browser/ui/tabs/tab_style.h"
 #include "chrome/browser/ui/tabs/tab_types.h"
 #include "chrome/browser/ui/ui_features.h"
+#include "chrome/browser/ui/tabs/features.h"
 #include "chrome/browser/ui/views/frame/browser_non_client_frame_view.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
 #include "chrome/browser/ui/views/frame/top_container_background.h"
@@ -1046,6 +1047,8 @@ void TabStyleViewsImpl::PaintBackgroundS
 }
 
 void TabStyleViewsImpl::PaintSeparators(gfx::Canvas* canvas) const {
+  if (tabs::AreHeliumVerticalTabsEnabled()) return;
+
   const auto separator_opacities = GetSeparatorOpacities(false);
   if (!separator_opacities.left && !separator_opacities.right) {
     return;
--- a/chrome/browser/ui/views/tabs/tab_width_constraints.cc
+++ b/chrome/browser/ui/views/tabs/tab_width_constraints.cc
@@ -10,8 +10,9 @@
 #include "ui/gfx/animation/tween.h"
 
 TabWidthConstraints::TabWidthConstraints(const TabLayoutState& state,
-                                         const TabSizeInfo& size_info)
-    : state_(state), size_info_(size_info) {}
+                                         const TabSizeInfo& size_info,
+                                         const bool part_of_group)
+    : state_(state), size_info_(size_info), part_of_group_(part_of_group) {}
 
 float TabWidthConstraints::GetMinimumWidth() const {
   const float min_width = state_.active() == TabActive::kActive
@@ -38,3 +39,7 @@ float TabWidthConstraints::TransformForP
     return width;
   }
 }
+
+bool TabWidthConstraints::IsPartOfGroup() const {
+  return part_of_group_;
+}
--- a/chrome/browser/ui/views/tabs/tab_width_constraints.h
+++ b/chrome/browser/ui/views/tabs/tab_width_constraints.h
@@ -12,7 +12,8 @@
 class TabWidthConstraints {
  public:
   TabWidthConstraints(const TabLayoutState& state,
-                      const TabSizeInfo& size_info);
+                      const TabSizeInfo& size_info,
+                      const bool part_of_group);
 
   // The smallest width this tab should ever have.
   float GetMinimumWidth() const;
@@ -26,6 +27,8 @@ class TabWidthConstraints {
   // The width this tab would like to have, if space is available.
   float GetPreferredWidth() const;
 
+  bool IsPartOfGroup() const;
+
   const TabLayoutState get_state() const { return state_; }
 
  private:
@@ -34,6 +37,7 @@ class TabWidthConstraints {
 
   TabLayoutState state_;
   TabSizeInfo size_info_;
+  bool part_of_group_;
 };
 
 #endif  // CHROME_BROWSER_UI_VIEWS_TABS_TAB_WIDTH_CONSTRAINTS_H_
